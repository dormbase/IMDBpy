
NOTE: due to a series of limitation, the current (2.5) release
contains an imdbpy2sql.py script that is _a lot_ slower than
specified below; to complete, it can take even 6 hours or more.

For the next release we plan to drop the use of SQLObject and
switch to SQLAlchemy or other tools, to restore acceptable performances.
If you want to help, please subscribe the imdbpy-devel mailing list at:
  http://imdbpy.sf.net/?page=help#ml
 

  SQL
  ===

Since version 2.1 it's possible to transfer the whole IMDb's
database from the plain text data files into a SQL database.
Starting with version 2.5 every database supported by the SQLObject
Object Relational Manager can be used to store and retrieve
movies and persons information.
This means that MySQL, PostgreSQL, SQLite, Firebird, MAX DB,
Sybase and MSSQL are supported and, as your read this text,
maybe other database backends were added.

You need the SQLObject package, at least version 0.8.

SQLObject home page: http://sqlobject.org/
SVN command to download the latest development version:
  svn co http://svn.colorstudy.com/SQLObject/trunk SQLObject


  SQL DATABASE INSTALLATION
  =========================

Select a mirror of the "The Plain Text Data Files" from
the http://www.imdb.com/interfaces.html page and download
every file in the main directory (beware that the "diffs"
subdirectory contains _a lot_ of files you _don't_ need,
so don't start mirroring everything!).

Starting from release 2.4, you can just download the files you need,
instead of every single file; the files not downloaded, will be skipped.
This feature is still quite untested, so please report any bug.


Create a database named "imdb" (or whatever you like),
using the tool provided by your database; as an example, for MySQL
you will use the 'mysqladmin' command:
  # mysqladmin -p create imdb
For PostgreSQL, you have to use the "createdb" command:
  # createdb -W imdb

To create the tables and to populate the database, you must run
the imdbpy2sql.py script:
  # imdbpy2sql.py -d /dir/with/plainTextDataFiles/ -u 'URI'

Where the 'URI' argument is a string representing the connection
to your database, with the schema:
  scheme://[user[:password]@]host[:port]/database[?parameters]

Where 'scheme' is one in "sqlite", "mysql", "postgres", "firebird",
"interbase", "maxdb", "sapdb", "mssql", "sybase".

Some examples:
    mysql://user:password@host/database
    mysql://host/database?debug=1
    postgres://user@host/database?debug=&cache=
    postgres:///full/path/to/socket/database
    postgres://host:5432/database
    sqlite:///full/path/to/database
    sqlite:/C|/full/path/to/database
    sqlite:/:memory:

For other information you can read the SQLObject documentation.

Notice that the command will take a long time to complete; I estimate
2 or 3 hours, depending on your hardware (I've tested MySQL 3.23; MySQL 5
seems to be somewhat slower, but maybe it's because I've not fine-tuned it).
It will also requires a lot of memory (RAM or swap space), in the
range of 150/200 megabytes.
In the end, the database will require between 1GB and 2GB of disc space.

The imdbpy2sql.py will print a lot of debug information on standard output;
you can save it in a file, appending (without quotes) "2>&1 | tee output.txt"


  NOTE
  ====

The performances are hugely dependant upon the underlying Python
module/package used to access the database.
MySQL, for instance, has a executemany() method of the cursor object
that accept multiple data insertion with a single SQL statement; other
database requires a call to the execute() method for every single row
of data, and they will be much slower - about 6 or 7 times slower than
MySQL.


  SQLITE NOTE
  ===========

It seems that, with older versions of the python-sqlite package, the first
run may fail; if you get a DatabaseError exception saying "no such table",
try running again the command with the same arguments.


  SQL USAGE
  =========

Now you can use IMDbPY with the database:
  from imdb import IMDb
  i = IMDb('sql', uri='YOUR_URI_STRING')
  resList = i.search_movie('the incredibles')
  for x in resList: print x
  ti = resList[0]
  i.update(ti)
  print ti['director'][0]

and so on...


